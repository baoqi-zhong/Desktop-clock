C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\install\keil_install\C51\BIN\C51.EXE Src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          ÍêÈ«¹Ø±Õ 20uA
   3          DS1302 2mA
   4          
   5          delay¸Ä³Éslp5ms ¾²Ì¬0.4mA
   6          */
   7          
   8          
   9          #include "STC8H.h"
  10          #include "stc_common.h"
  11          #include "main.h"
  12          #include <intrins.h>
  13          
  14          
  15          unsigned char mode = MODE_TIME;
  16          unsigned char settings_focus = 0;
  17          
  18          unsigned char shutdown_mode_flag = 0; // 0ÎÞ 1¹Ø±ÕËùÓÐ
  19          
  20          unsigned char now_time[5] = {12, 00, 12, 5, 1};
  21          unsigned char display_num_data[4];
  22          
  23          unsigned char BTN1_INT_FLAG=0, BTN2_INT_FLAG=0;
  24          unsigned char btn1_press_time=0, btn2_press_time=0; // ¼ÇÂ¼¸÷¸ö°´Å¥³¤°´µÄÀÛ¼ÆÊ±¼ä
  25          unsigned char btn_state = 0, add_state;
  26          
  27          unsigned char time_12 = 0;
  28          unsigned char edit = 0; // ÊÇ·ñ´¦ÓÚ±à¼­ÖÐ
  29          unsigned char lift = 0;
  30          
  31          unsigned char max_[3]; // ¸÷¸öÎ»µÄ×î´óÊýÖµ£¬¶¯Ì¬ÉèÖÃ
  32          unsigned char hot_num = 0; // ÕýÔÚÐÞ¸ÄµÄÊÇÇ°Á½Î»»¹ÊÇºóÁ½Î»£¬0/1
  33          unsigned char last_blink = 0;
  34          
  35          unsigned char refresh_screen_now = 1;
  36          unsigned int refresh_count = 0x01;
  37          unsigned char add_count = ADD_DT;
  38          
  39          
  40          void high_speed()
  41          {
  42   1        TR0 = 0; // ¹Ø±Õ¶¨Ê±Æ÷
  43   1        P_SW2 = 0x80;
  44   1        
  45   1        HIRCCR |= 0x80; // ´ò¿ªHRC
  46   1        while(!(HIRCCR & 1));
  47   1        CLKSEL = 0; // ÄÚ²¿32K  
  48   1        CLKDIV = 15; // »Ö¸´Ä¬ÈÏ  
  49   1        IRC32KCR &= 0x7F; // ¹Ø±ÕLRC
  50   1        P_SW2 = 0x00; 
  51   1      }
  52          
  53          void low_speed()
  54          {
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 2   

  55   1        P_SW2 = 0x80;
  56   1        IRC32KCR |= 0x80; // ´ò¿ªLRC
  57   1        while(!(IRC32KCR & 1));
  58   1        CLKSEL = 3; // ÄÚ²¿32K
  59   1        CLKDIV = 0;
  60   1        HIRCCR &= 0x7F; // ¹Ø±ÕHRC
  61   1      
  62   1        P_SW2 = 0x00; 
  63   1        TR0 = 1; // ´ò¿ª¶¨Ê±Æ÷
  64   1      }
  65          
  66          void delay_1ms()
  67          {
  68   1        WKTCL=0x02;
  69   1        WKTCH=0x80;
  70   1        
  71   1        PCON = 0x02;
  72   1        _nop_();
  73   1        _nop_();
  74   1      }
  75          
  76          void delay_5ms()
  77          {
  78   1        WKTCL=0x09;
  79   1        WKTCH=0x80;
  80   1        
  81   1        PCON = 0x02;
  82   1        _nop_();
  83   1        _nop_();
  84   1      }
  85          
  86          //void delay(unsigned int time)
  87          //{
  88          //  unsigned int time_;
  89          //  P_SW2 = 0x80;
  90          //  if(CLKDIV==15)
  91          //  {
  92          //    P_SW2 = 0x00;
  93          //    for(time_=0;time_<time;time_++)
  94          //    {
  95          //      unsigned char i, j; // 2MHz
  96          //      i = 2;
  97          //      j = 239;
  98          //      do
  99          //      {
 100          //        while (--j);
 101          //      } while (--i);
 102          //    }
 103          //  }
 104          //  else
 105          //  {
 106          //    P_SW2 = 0x00;
 107          //    for(time_=0;time_<time;time_++)
 108          //    {
 109          //      unsigned char i; // 32KHz
 110          //      i = 8;
 111          //      while (--i);
 112          //    }
 113          //  }
 114          //}
 115          
 116          
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 3   

 117          void shutdown()
 118          {
 119   1        // ±ê×¼Ë«Ïò
 120   1        P0M0 = 0x03;
 121   1        P0M1 = 0x03;
 122   1        P1M0 = 0x00;
 123   1        P1M1 = 0x00;
 124   1        P2M0 = 0x00;
 125   1        P2M1 = 0x00;
 126   1        P3M0 = 0x00;
 127   1        P3M1 = 0x0F;
 128   1      
 129   1        P4M0 = 0x00;
 130   1        P4M1 = 0x00;
 131   1        P5M0 = 0x00;
 132   1        P5M1 = 0x00;
 133   1      
 134   1        P0 = 0;
 135   1        P1 = 0;
 136   1        P2 = 0;
 137   1        P3 = 0;
 138   1        P4 = 0;
 139   1        P5 = 0;
 140   1      
 141   1        DS1302_VCC = DS1302_VCC_OFF;
 142   1        
 143   1        WKTCL=0xFE;  // µôµç»½ÐÑ¶¨Ê±Æ÷
 144   1        WKTCH=0xFF;
 145   1        
 146   1        shutdown_mode_flag = 1;
 147   1        PCON = 0x02;
 148   1        _nop_();
 149   1        _nop_();
 150   1        
 151   1        refresh_count = 1;
 152   1        refresh_screen_now = 0;
 153   1      }
 154          
 155          
 156          // DS1302
 157          void DS1302_shift_out(unsigned char data_)
 158          {
 159   1        unsigned char i;
 160   1        P36_OUT_EN; // DS1302_DAT
 161   1        for (i = 0; i < 8; i++)
 162   1        {
 163   2          // 1302ÏÈ´«ÈëµÄÊÇµÍÎ»µÄ
 164   2          DS1302_DAT = data_ >> i & 1;
 165   2          //ÉÏÉýÑØÐ´Êý¾Ý
 166   2          DS1302_CLK = 1;
 167   2          DS1302_CLK = 0;
 168   2        }
 169   1      }
 170          
 171          unsigned char DS1302_shift_in()
 172          {
 173   1        unsigned char i, data_=0;
 174   1        P36_IN_EN; // DS1302_DAT
 175   1        for (i = 0; i < 8; i++)
 176   1        {
 177   2          //ÏÂ½µÑØ¶ÁÊý¾Ý ÔÚDS1302_shift_outº¯ÊýÀ­µÍÖ®ºóÂíÉÏ¶Á
 178   2          if (DS1302_DAT==1)
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 4   

 179   2            data_ |= 1 << i;
 180   2          
 181   2          DS1302_CLK = 1;
 182   2          DS1302_CLK = 0;
 183   2        }
 184   1        return data_;
 185   1      }
 186          
 187          void DS1302_write(unsigned char address, unsigned char data_)
 188          {
 189   1        DS1302_DAT = 0;
 190   1      
 191   1        DS1302_RST = 1;
 192   1        DS1302_shift_out(address);
 193   1        DS1302_shift_out(data_);
 194   1        DS1302_RST = 0;
 195   1        
 196   1      }
 197          
 198          unsigned char DS1302_read(unsigned char address)
 199          {
 200   1        unsigned char data_;
 201   1      
 202   1        DS1302_DAT = 0;
 203   1      
 204   1        DS1302_RST = 1;
 205   1        DS1302_shift_out(address);
 206   1        data_ = DS1302_shift_in();
 207   1        DS1302_RST = 0;
 208   1        return data_;
 209   1      }
 210          
 211          void DS1302_power_on()
 212          {
 213   1        DS1302_VCC = DS1302_VCC_ON;
 214   1        delay_5ms();
 215   1      }
 216          
 217          void DS1302_power_off()
 218          {
 219   1        delay_5ms();
 220   1        DS1302_VCC = DS1302_VCC_OFF;
 221   1      }
 222          
 223          void DS1302_init()
 224          {
 225   1        DS1302_power_on();
 226   1        DS1302_write(0x8E, 0x00); // Ð´±£»¤off
 227   1        
 228   1        //DS1302_write(0x90, 0xA5); // ³äµç
 229   1        set_now_time();
 230   1        DS1302_write(0x8C, 0x22); // year
 231   1        DS1302_write(0x80, DS1302_read(0x81) & 0x7F); // ¾§ÕñÆðÕð // bug:Ã¿´ÎÉèÖÃÃëÖ®ºó£¬ºÁÃë»áÇåÁã¡£ËùÒÔÔÚ1sÄÚ²
             -»¶ÏresetµÄ»°£¬Ê±¼ä»á¿¨×¡²»¶¯
 232   1      
 233   1        DS1302_write(0x8E, 0x80); // Ð´±£»¤on
 234   1        DS1302_power_off();
 235   1      }
 236          
 237          void read_now_time()
 238          {
 239   1        unsigned char time_data, power_flag;
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 5   

 240   1        
 241   1        power_flag = DS1302_VCC;
 242   1        if(power_flag == DS1302_VCC_OFF)
 243   1          DS1302_power_on();
 244   1      
 245   1        time_data = DS1302_read(0x85); // hour
 246   1        now_time[NOW_TIME_HOUR] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 247   1      
 248   1        time_data = DS1302_read(0x83); // min
 249   1        now_time[NOW_TIME_MINUTE] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 250   1      
 251   1        time_data = DS1302_read(0x89); // month
 252   1        now_time[NOW_TIME_MONTH] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 253   1        
 254   1        time_data = DS1302_read(0x87); // day
 255   1        now_time[NOW_TIME_DAY] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 256   1        
 257   1        
 258   1        now_time[NOW_TIME_WEEKDAY] = DS1302_read(0x8B); // week
 259   1        
 260   1        if(power_flag == DS1302_VCC_OFF)
 261   1          DS1302_power_off();
 262   1      }
 263          
 264          void set_now_time()
 265          {
 266   1        unsigned char power_flag;
 267   1        power_flag = DS1302_VCC;
 268   1        if(power_flag == DS1302_VCC_OFF)
 269   1          DS1302_power_on();
 270   1        
 271   1        DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 272   1        DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // min
 273   1        DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // month
 274   1        DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
 275   1        DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
 276   1        
 277   1        if(power_flag == DS1302_VCC_OFF)
 278   1          DS1302_power_off();
 279   1      }
 280          
 281          
 282          // screen
 283          void SCREEN_shift(unsigned char data_)
 284          {
 285   1        SPDAT = data_;
 286   1        while (!(SPSTAT & 0x80));
 287   1        SPSTAT = 0xc0;   
 288   1      }
 289          
 290          void SCREEN_write_cmd(unsigned char cmd)
 291          {
 292   1        SCREEN_DC = 0;
 293   1        SCREEN_shift(cmd);
 294   1      }
 295          
 296          void SCREEN_write_data(unsigned char data_)
 297          {
 298   1        SCREEN_DC = 1;
 299   1        SCREEN_shift(data_);
 300   1      }
 301          
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 6   

 302          void SCREEN_clear()
 303          {
 304   1        unsigned char x,y;
 305   1        high_speed();
 306   1        for (y = 0; y < 8; y++)
 307   1        {
 308   2          SCREEN_write_cmd(0xB0 + y);//ÐÐ
 309   2          SCREEN_write_cmd(0x00);//ÆðÊ¼x
 310   2          SCREEN_write_cmd(0x10);//ÆðÊ¼x
 311   2          SCREEN_DC = 1;
 312   2          for (x = 0; x < 128; x++)
 313   2          {
 314   3            SCREEN_shift(0x00);
 315   3          }
 316   2        }
 317   1        low_speed();
 318   1      }
 319          
 320          void SCREEN_init()
 321          {
 322   1        const unsigned char code init_cmds[] = {
 323   1          0xE2, // Èí¼þ¸´Î»
 324   1          
 325   1          0x2F, // ¿ªÉýÑ¹Æ÷ ¿ªµçÑ¹µ÷ÕûÆ÷ ¿ªµçÑ¹¸úËæÆ÷
 326   1          
 327   1          0x24, // ´Öµ÷¶Ô±È¶È
 328   1          0x81, 31, // Ï¸µ÷¶Ô±È¶È
 329   1      
 330   1          0x40, // ÉèÖÃpage1
 331   1          0xC8, // ÉÏÏÂµßµ¹
 332   1          0xAF,// ´ò¿ªÏÔÊ¾
 333   1        };
 334   1        unsigned char i;
 335   1        
 336   1        SCREEN_RST = 0;
 337   1        delay_1ms();
 338   1        SCREEN_RST = 1;
 339   1        
 340   1        SCREEN_CS = 0;
 341   1        SCREEN_BG = 0;
 342   1        
 343   1        // SPI init
 344   1        SPCTL = 0xD0;                               //Ê¹ÄÜSPIÖ÷»úÄ£Ê½ ºöÂÔSSÖ÷´Ó»úÑ¡ÔñÒý½Å
 345   1        SPSTAT = 0xc0;                              //ÇåÖÐ¶Ï±êÖ¾
 346   1        
 347   1        SCREEN_DC = 0; // cmd
 348   1        for (i = 0; i < 8; i++)
 349   1        {
 350   2          SCREEN_write_cmd(init_cmds[i]);
 351   2          delay_1ms();
 352   2        }
 353   1        SCREEN_clear();
 354   1      }
 355          
 356          void print_line(unsigned char start_x, unsigned char start_y, char words[])
 357          {
 358   1        unsigned char x, character;
 359   1        SCREEN_write_cmd(0xB0 + start_y); //ÐÐ
 360   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 361   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 362   1      
 363   1        character = 0; // ´«ÈëµÄwords½áÎ²ÊÇ\0 (ºóÃæÓÃcharacterµÄÊ±ºòÒª-1)
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 7   

 364   1        while (words[character++])
 365   1        {
 366   2          SCREEN_DC = 1; // data
 367   2          for (x = 0; x < 5; x++)
 368   2            SCREEN_shift(FONT[(words[character - 1] - START_CHAR) * 5 + x]);
 369   2          SCREEN_shift(0x00);
 370   2        }
 371   1      }
 372          
 373          void print_var(unsigned char start_x, unsigned char start_y, unsigned char num, unsigned char len)
 374          {
 375   1        unsigned char x;
 376   1        SCREEN_write_cmd(0xB0 + start_y); //ÐÐ
 377   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 378   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 379   1        
 380   1        SCREEN_DC = 1; // data
 381   1        if(len==3)
 382   1        {
 383   2          for (x = 0; x < 5; x++)
 384   2            SCREEN_shift(FONT[('0' + num/100 - START_CHAR) * 5 + x]);
 385   2          SCREEN_shift(0x00);
 386   2        }
 387   1        if(len>=2)
 388   1        {
 389   2          for (x = 0; x < 5; x++)
 390   2            SCREEN_shift(FONT[('0' + num/10%10 - START_CHAR) * 5 + x]);
 391   2          SCREEN_shift(0x00);
 392   2        }
 393   1        if(len>=1)
 394   1        {
 395   2          for (x = 0; x < 5; x++)
 396   2            SCREEN_shift(FONT[('0' + num%10 - START_CHAR) * 5 + x]);
 397   2          SCREEN_shift(0x00);
 398   2        }
 399   1      }
 400          
 401          
 402          void print_big_num(unsigned char start_x, unsigned char start_y,unsigned char num)
 403          {
 404   1        unsigned char x, y;
 405   1        for (y = 0; y < 5; y++)
 406   1        {
 407   2          SCREEN_write_cmd(0xB0 + start_y + y); //ÐÐ
 408   2          SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 409   2          SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 410   2          
 411   2          SCREEN_DC = 1; // data
 412   2          if(num==10)
 413   2            for (x = 0; x < 24; x++)
 414   2              SCREEN_shift(0x00);
 415   2          else
 416   2            for (x = 0; x < 24; x++)
 417   2              SCREEN_shift(BIG_NUM_FONT[num*120 + y*24+x]);
 418   2         }
 419   1      }
 420          
 421          void print_small_num(unsigned char start_x, unsigned char start_y,unsigned char num)
 422          {
 423   1        unsigned char x, y;
 424   1        for (y = 0; y < 4; y++)
 425   1        {
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 8   

 426   2          SCREEN_write_cmd(0xB0 + start_y + y); //ÐÐ
 427   2          SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 428   2          SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 429   2          
 430   2          SCREEN_DC = 1; // data
 431   2          if(num==10)
 432   2            for (x = 0; x < 16; x++)
 433   2              SCREEN_shift(0x00);
 434   2          else
 435   2            for (x = 0; x < 16; x++)
 436   2              SCREEN_shift(SMALL_NUM_FONT[num*48 + y*16+x]);
 437   2         }
 438   1      }
 439          
 440          void print_time(unsigned char start_x, unsigned char start_y,unsigned char nums[])
 441          {
 442   1        unsigned char x,digit;
 443   1       
 444   1        last_blink = 1 - last_blink;
 445   1        if (edit == 1 && last_blink==0 && btn_state!=4)
 446   1        {
 447   2          if (hot_num == 0)
 448   2          {
 449   3            display_num_data[0] = 10;
 450   3            display_num_data[1] = 10;
 451   3          }
 452   2          else
 453   2          {
 454   3            display_num_data[2] = 10;
 455   3            display_num_data[3] = 10;
 456   3          }
 457   2        }
 458   1        
 459   1        if(display_num_data[0] == 0)
 460   1          display_num_data[0] = 10;
 461   1        
 462   1        for(digit=0;digit<4;digit++)
 463   1        {
 464   2          print_big_num(start_x+NUM_START_OFFSET[digit], start_y,nums[digit]);
 465   2        }
 466   1        
 467   1        start_x += NUM_START_OFFSET[4];
 468   1        SCREEN_write_cmd(0xB1 + start_y); //ÐÐ
 469   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 470   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 471   1        
 472   1        SCREEN_DC = 1; // data
 473   1        for (x = 0; x < 4; x++)
 474   1          SCREEN_shift(0x7E);
 475   1        
 476   1        SCREEN_write_cmd(0xB3 + start_y); //ÐÐ
 477   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 478   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 479   1        
 480   1        SCREEN_DC = 1; // data
 481   1        for (x = 0; x < 4; x++)
 482   1          SCREEN_shift(0x7E);
 483   1      }
 484          
 485          void update_display_num_data()
 486          {
 487   1        // Õý³£ÏÔÊ¾Ö÷Ê±¼ä
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 9   

 488   1      
 489   1        if(time_12 && now_time[NOW_TIME_HOUR]>12)
 490   1        {
 491   2          display_num_data[0] = (now_time[NOW_TIME_HOUR] - 12) / 10;
 492   2          display_num_data[1] = (now_time[NOW_TIME_HOUR] - 12) % 10;
 493   2        }
 494   1        else
 495   1        {
 496   2          display_num_data[0] = now_time[NOW_TIME_HOUR] / 10;
 497   2          display_num_data[1] = now_time[NOW_TIME_HOUR] % 10;
 498   2        }
 499   1      
 500   1        display_num_data[2] = now_time[NOW_TIME_MINUTE] / 10;
 501   1        display_num_data[3] = now_time[NOW_TIME_MINUTE] % 10;
 502   1      }
 503          
 504          
 505          void draw_class(unsigned char day)
 506          {
 507   1        // day ´ÓÁã¿ªÊ¼
 508   1        unsigned char line, x, lesson;
 509   1        unsigned int temp;
 510   1      
 511   1        for (line = 0; line < 2; line++)
 512   1        {
 513   2          SCREEN_write_cmd(0xB2 +line); //ÐÐ
 514   2          SCREEN_write_cmd(0x00); //ÆðÊ¼x µÍ4Î»
 515   2          SCREEN_write_cmd(0x10); //ÆðÊ¼x ¸ß4Î»
 516   2          
 517   2          SCREEN_DC = 1; // data
 518   2          for(lesson = 0; lesson<9; lesson++)
 519   2          {
 520   3            temp = lesson_table[lesson+day*9]*28+line*14; 
 521   3            if(lesson==5)
 522   3            {
 523   4              SCREEN_shift(0x00);
 524   4              SCREEN_shift(0x00);
 525   4              SCREEN_shift(0x00);
 526   4            }
 527   3            for (x = 0; x <14; x++)
 528   3            {
 529   4              SCREEN_shift(CHINESE_FONT[temp+x]);
 530   4            }
 531   3          }
 532   2        }
 533   1      }
 534          
 535          void print_small_time(unsigned char start_x, unsigned char start_y, unsigned char now_time_hour, unsigned 
             -char now_time_min)
 536          {
 537   1        if(time_12 && now_time_hour>12)
 538   1          now_time_hour = now_time_hour%12;
 539   1      
 540   1         
 541   1        if(now_time_hour>=10)
 542   1          print_var(start_x, start_y, now_time_hour,2);
 543   1        else
 544   1        {
 545   2          print_line(start_x, start_y, " ");
 546   2          print_var(start_x+5, start_y, now_time_hour,1);
 547   2        }
 548   1        
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 10  

 549   1        print_line(start_x+12, start_y, ":");
 550   1        print_var(start_x+17, start_y, now_time_min,2);
 551   1      
 552   1      }
 553          
 554          void print_next_time(unsigned char start_x, unsigned char start_y)
 555          {
 556   1        unsigned char i;
 557   1        unsigned int now_time_hour, now_time_min;
 558   1        now_time_min = now_time[NOW_TIME_HOUR]*60+now_time[NOW_TIME_MINUTE];
 559   1        for(i=0;i<23;i++)
 560   1        {
 561   2          if(now_time_min<time_table[i])
 562   2            break;
 563   2        }
 564   1        now_time_hour = time_table[i]/60;
 565   1        
 566   1        print_small_time(start_x, start_y, now_time_hour, time_table[i]%60);
 567   1      }
 568          
 569          void draw_chinese(unsigned char start_x, unsigned char start_y, unsigned char chinese)
 570          {
 571   1        unsigned char line,x;
 572   1        
 573   1        for (line = 0; line < 2; line++)
 574   1        {
 575   2          SCREEN_write_cmd(0xB0 + start_y + line); //ÐÐ
 576   2          SCREEN_write_cmd(start_x & 0x0F); //ÆðÊ¼x µÍ4Î»
 577   2          SCREEN_write_cmd(0x10 + (start_x>>4)); //ÆðÊ¼x ¸ß4Î»
 578   2          
 579   2          SCREEN_DC = 1; // data
 580   2          for (x = 0; x <14; x++)
 581   2          {
 582   3            SCREEN_shift(CHINESE_FONT[chinese*28+line*14+x]);
 583   3          }
 584   2        }
 585   1      }
 586          void print_day_and_date()
 587          {
 588   1        last_blink = 1-last_blink;
 589   1        
 590   1        if(edit && last_blink==0)
 591   1        {
 592   2          if(hot_num==0)
 593   2            print_line(2,0,"  ");
 594   2          if(hot_num==1)
 595   2            print_line(18,0,"  ");
 596   2          if(hot_num==2)
 597   2            print_line(35,0, "          ");
 598   2        }
 599   1        else
 600   1        {
 601   2          print_line(13, 0, ".");
 602   2          print_var(2,0,now_time[NOW_TIME_MONTH], 2);
 603   2          print_var(18,0,now_time[NOW_TIME_DAY], 2);
 604   2          print_line(35,0, WEEK_NAME[now_time[NOW_TIME_WEEKDAY]-1]);
 605   2        }
 606   1      }
 607          
 608          void draw_count_down()
 609          {
 610   1        unsigned char x;
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 11  

 611   1        signed int remained_day;
 612   1        
 613   1        remained_day = MONTH_TO_COUNTDOWN[now_time[NOW_TIME_MONTH] - 1] - now_time[NOW_TIME_DAY];
 614   1        if(remained_day<0)
 615   1          remained_day = 0;
 616   1          
 617   1        if(remained_day>99)
 618   1          print_small_num(60,5,remained_day/100);
 619   1        else
 620   1          print_small_num(60,5,10);
 621   1        
 622   1        if(remained_day>9)
 623   1          print_small_num(78,5,(remained_day/10)%10);
 624   1        else
 625   1          print_small_num(78,5,10);
 626   1        
 627   1        print_small_num(96,5,remained_day%10);
 628   1        
 629   1        for (x = 0; x < 4; x++)
 630   1          draw_chinese(14*x,6,14+x);
 631   1      
 632   1        draw_chinese(114,6,18);
 633   1      }
 634          
 635          //void draw_count_down_big()
 636          //{
 637          //  signed int remained_day;
 638          //  
 639          //  remained_day = MONTH_TO_COUNTDOWN[now_time[NOW_TIME_MONTH] - 1] - now_time[NOW_TIME_DAY];
 640          //  if(remained_day<0)
 641          //    remained_day = 0;
 642          //  
 643          //  if(remained_day>99)
 644          //    print_big_num(22,2,remained_day/100);
 645          //  else
 646          //    print_big_num(22,2,10);
 647          //  
 648          //  if(remained_day>9)
 649          //    print_big_num(54,2,(remained_day/10)%10);
 650          //  else
 651          //    print_big_num(54,2,10);
 652          //  
 653          //  print_big_num(86,2,remained_day%10);
 654          //  
 655          //  draw_chinese(2,2,14);
 656          //  draw_chinese(2,5,15);
 657          //  draw_chinese(114,5,18);
 658          //}
 659          
 660          void draw_calendar()
 661          {
 662   1        unsigned char x, y, i, day_count, start_day, month_days;
 663   1        
 664   1        start_day = (35+now_time[NOW_TIME_WEEKDAY]-now_time[NOW_TIME_DAY])%7;
 665   1      
 666   1        month_days = MAX_MONTH_DAYS[now_time[NOW_TIME_MONTH]-1];
 667   1      
 668   1        day_count = 0;
 669   1        for(x=0;x<start_day;x++)
 670   1        {
 671   2          print_line(x*19+4, 2, " ");
 672   2      
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 12  

 673   2        }
 674   1        for(x=start_day;x<7;x++)
 675   1        {
 676   2          day_count ++;
 677   2          print_var(x*19+4, 2, day_count, 1);
 678   2          
 679   2        }
 680   1        for(y=1;y<6;y++)
 681   1        {
 682   2          for(x=0;x<7;x++)
 683   2          {
 684   3            day_count ++;
 685   3            if(day_count > month_days)
 686   3              print_line(x*19+1, y+2, "  ");
 687   3            else
 688   3            {
 689   4              if(day_count<10)
 690   4              {
 691   5                print_line(x*19+1, y+2, "  ");
 692   5                print_var(x*19+4, y+2, day_count, 1);
 693   5              }
 694   4              else
 695   4                print_var(x*19+1, y+2, day_count, 2);
 696   4              
 697   4            }
 698   3      
 699   3          }
 700   2        }
 701   1        
 702   1        // table
 703   1        for(y=0;y<6;y++)
 704   1        {
 705   2          SCREEN_write_cmd(0xB2 + y); //ÐÐ
 706   2          for(x=0;x<6;x++)
 707   2          {
 708   3            SCREEN_write_cmd(0x00 + ((x*19+16) & 0xF)); //ÆðÊ¼x µÍ4Î»
 709   3            SCREEN_write_cmd(0x10 + ((x*19+16) >> 4)); //ÆðÊ¼x ¸ß4Î»
 710   3            SCREEN_write_data(0xFF);
 711   3          }
 712   2        }
 713   1        
 714   1        // ±ê³ö½ñÌì
 715   1        
 716   1        y = (start_day + now_time[NOW_TIME_DAY]-1) / 7;
 717   1        SCREEN_write_cmd(0xB2 + y); //ÐÐ
 718   1        SCREEN_write_cmd(0x00 + ((now_time[NOW_TIME_WEEKDAY]*19-21) & 0xF)); //ÆðÊ¼x µÍ4Î»
 719   1        SCREEN_write_cmd(0x10 + ((now_time[NOW_TIME_WEEKDAY]*19-21) >> 4)); //ÆðÊ¼x ¸ß4Î»
 720   1      
 721   1        SCREEN_write_data(0xFF);
 722   1        SCREEN_write_data(0xFF);
 723   1        
 724   1        SCREEN_write_cmd(0x00 + ((now_time[NOW_TIME_WEEKDAY]*19-5) & 0xF)); //ÆðÊ¼x µÍ4Î»
 725   1        SCREEN_write_cmd(0x10 + ((now_time[NOW_TIME_WEEKDAY]*19-5) >> 4)); //ÆðÊ¼x ¸ß4Î»
 726   1      
 727   1        SCREEN_write_data(0xFF);
 728   1        SCREEN_write_data(0xFF);
 729   1        
 730   1        
 731   1        // ÐÇÆÚ
 732   1        SCREEN_write_cmd(0xB1); //ÐÐ
 733   1        SCREEN_write_cmd(0x00); //ÆðÊ¼x µÍ4Î»
 734   1        SCREEN_write_cmd(0x10); //ÆðÊ¼x ¸ß4Î»
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 13  

 735   1        
 736   1        SCREEN_DC = 1; // data   
 737   1        for (i = 0; i < 3; i++)
 738   1          SCREEN_shift(0x20); 
 739   1      
 740   1        for(x=0;x<7;x++)
 741   1        { 
 742   2          SCREEN_shift(0x00); 
 743   2          for (i = 0; i < 5; i++)
 744   2            SCREEN_shift(FONT[(WEEK_NAME[x][0] - START_CHAR) * 5 + i]);
 745   2          SCREEN_shift(0x00); 
 746   2          for (i = 0; i < 6; i++)
 747   2            SCREEN_shift(0x20);
 748   2          SCREEN_shift(0xE0); 
 749   2          for (i = 0; i < 5; i++)
 750   2            SCREEN_shift(0x20);
 751   2        }
 752   1      
 753   1      
 754   1      }
 755          
 756          int cap;
 757          unsigned long adc;
 758          
 759          void refresh_screen()
 760          {
 761   1        unsigned char time_data;
 762   1        high_speed();
 763   1        
 764   1        if(mode==MODE_TIME)
 765   1        {
 766   2          time_data = DS1302_read(0x85); // hour
 767   2          now_time[NOW_TIME_HOUR] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 768   2      
 769   2          time_data = DS1302_read(0x83); // min
 770   2          now_time[NOW_TIME_MINUTE] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 771   2      
 772   2          update_display_num_data();
 773   2          
 774   2          if(now_time[NOW_TIME_HOUR]>12)
 775   2            print_line(2,0, "PM");
 776   2          else
 777   2            print_line(2,0, "AM");
 778   2          
 779   2          print_next_time(98, 0);
 780   2      
 781   2          print_time(2,2,display_num_data);
 782   2          SCREEN_BG = 0;
 783   2        }
 784   1      //  else if (mode == MODE_COUNT_DOWN)
 785   1      //  {
 786   1      //    read_now_time();
 787   1      //    
 788   1      //    print_day_and_date();
 789   1      //    
 790   1      //    print_small_time(98,0,now_time[NOW_TIME_HOUR], now_time[NOW_TIME_MINUTE]);
 791   1      //    
 792   1      //    draw_count_down_big();
 793   1      //  }
 794   1        else if (mode == MODE_CLASS)
 795   1        {
 796   2          read_now_time();
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 14  

 797   2          print_day_and_date();
 798   2          
 799   2          // 6µãÖÓÖ®ºóÏÔÊ¾µÚ¶þÌìµÄ¿Î±í
 800   2          if(now_time[NOW_TIME_HOUR] > 17)
 801   2          {
 802   3            print_line(99,0, "tomo");
 803   3            draw_class(now_time[NOW_TIME_WEEKDAY] % 7);
 804   3          }
 805   2          else
 806   2          {
 807   3            print_line(99,0, "today");
 808   3            draw_class(now_time[NOW_TIME_WEEKDAY] - 1);
 809   3          }
 810   2          draw_count_down();
 811   2      
 812   2          SCREEN_BG = 0;
 813   2        }
 814   1        else if (mode == MODE_CALENDAR)
 815   1        {
 816   2          read_now_time();
 817   2          
 818   2          print_day_and_date();
 819   2          
 820   2          draw_calendar();
 821   2        }
 822   1        else if (mode == MODE_SETTING)
 823   1        {
 824   2          print_line(2,0, "Countdown Clock V4.2");
 825   2          print_line(2,1, "Present to Liang QC");
 826   2          //print_line(2,1, "Present to Lao JJ");
 827   2          
 828   2          ADC_CONTR |= 0x80; // power on
 829   2          delay_1ms();
 830   2          delay_1ms();
 831   2          
 832   2          ADC_CONTR |= 0x40; // start convert
 833   2          _nop_();
 834   2          _nop_();
 835   2          while (!(ADC_CONTR & 0x20));
 836   2          ADC_CONTR &= ~0x20; // clr flag power off
 837   2          
 838   2          adc = ADC_RES;
 839   2          if(adc<73)
 840   2            adc = 73;
 841   2          else if(adc>83)
 842   2            adc = 83;
 843   2          
 844   2          cap = 100-10*(adc-73);
 845   2          
 846   2          print_line(2,3,"Battery:"); 
 847   2          if(cap==100)
 848   2          {
 849   3            print_var(50,3,cap,3);
 850   3            print_line(70,3,"%"); 
 851   3          }
 852   2          else
 853   2          {
 854   3            print_var(50,3,cap,2);
 855   3            print_line(64,3,"%"); 
 856   3          }
 857   2      
 858   2          
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 15  

 859   2          print_line(2,6, "- Presented by");
 860   2          print_line(2,7, "- Baoqi-zhong :D");
 861   2      
 862   2          SCREEN_BG = 0;
 863   2        }
 864   1        
 865   1        low_speed();
 866   1      }
 867          
 868          void btn()
 869          {
 870   1        if (lift == 1) // »¹Ã»³¤°´¹»
 871   1        {
 872   2          if (BTN1_INT_FLAG == 1 && BTN2_INT_FLAG == 0)
 873   2            btn1_press_time ++;
 874   2          else
 875   2            btn1_press_time = 0;
 876   2          
 877   2          if (BTN2_INT_FLAG == 1 && BTN1_INT_FLAG == 0)
 878   2            btn2_press_time ++;
 879   2          else
 880   2            btn2_press_time = 0;
 881   2        }
 882   1        
 883   1        if (btn1_press_time > LONG_PRESS_TIME)
 884   1        {
 885   2          // btn1 ³¤°´
 886   2          btn_state = 2;
 887   2          btn1_press_time = 0;
 888   2          lift = 0;
 889   2        }
 890   1        if (btn2_press_time > LONG_PRESS_TIME)
 891   1        {
 892   2          // btn2 ³¤°´
 893   2          btn_state = 4;
 894   2          btn2_press_time = 0;
 895   2          lift = 0;
 896   2        }
 897   1      }
 898          
 899          void btn_process()
 900          {
 901   1        unsigned char power_flag;
 902   1      
 903   1        if (btn_state == 1 & edit==0 & settings_focus==0) //btn1 ¶Ì
 904   1        {
 905   2          // delay(1);
 906   2          WKTCL=0x02;
 907   2          WKTCH=0x80;
 908   2          
 909   2          PCON = 0x02;
 910   2          _nop_();
 911   2          _nop_();
 912   2          
 913   2          mode = (mode + 1) % MAX_MODE;
 914   2          SCREEN_clear();
 915   2          refresh_screen_now = 1;
 916   2          btn_state = 0;
 917   2         
 918   2          return;
 919   2        }
 920   1        
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 16  

 921   1        if (btn_state == 2) //btn1 ³¤
 922   1        {
 923   2          if (mode!=MODE_SETTING)
 924   2          {
 925   3            refresh_screen_now = 1;
 926   3            if (edit)
 927   3            {
 928   4              edit = 0;
 929   4              //TMR0_DIS;
 930   4              DS1302_write(0x8E, 0x80);
 931   4              DS1302_power_off();
 932   4            }
 933   3            else
 934   3            {
 935   4              edit = 1;
 936   4              hot_num = 0;
 937   4              refresh_count = 0x10;
 938   4              add_count = ADD_DT;
 939   4              //TMR0_EN;
 940   4              DS1302_power_on();
 941   4              DS1302_write(0x8E, 0x00);
 942   4            }
 943   3            btn_state = 0;
 944   3            return;
 945   3          }
 946   2          else
 947   2          {
 948   3            btn_state = 0;
 949   3            return;
 950   3          }
 951   2      
 952   2        }
 953   1      
 954   1        
 955   1        if(mode==MODE_TIME)
 956   1        {
 957   2          max_[0] = 24;
 958   2          max_[1] = 60; 
 959   2          if(edit)
 960   2          {
 961   3            if (btn_state == 1) //btn1 ¶Ì
 962   3            {
 963   4              hot_num = 1 - hot_num;
 964   4              refresh_screen_now = 1;
 965   4              btn_state = 0;
 966   4              return;
 967   4            }
 968   3            if (btn_state == 3) //btn2 ¶Ì
 969   3            {
 970   4              now_time[hot_num] = (now_time[hot_num] + 1) % max_[hot_num];
 971   4              DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 972   4              DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // min
 973   4              refresh_screen_now = 1;
 974   4              last_blink = 0;
 975   4              btn_state = 0;
 976   4              return;
 977   4            }
 978   3            
 979   3            if(btn_state == 4)// btn2 ³¤
 980   3            {
 981   4              add_count--;
 982   4              if(add_count==0)
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 17  

 983   4              {
 984   5                add_count = ADD_DT;
 985   5                now_time[hot_num] = (now_time[hot_num] + 1) % max_[hot_num];
 986   5                DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 987   5                DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // m
             -in
 988   5                refresh_screen_now = 1;
 989   5                last_blink = 0;
 990   5                return;
 991   5              }
 992   4            }
 993   3          }
 994   2          else
 995   2          {
 996   3            if (btn_state == 3) //btn2 ¶Ì
 997   3            {
 998   4              
 999   4              time_12 = 1 - time_12;
1000   4              
1001   4              power_flag = DS1302_VCC;
1002   4              if(power_flag == DS1302_VCC_OFF)
1003   4                DS1302_power_on();
1004   4              
1005   4              DS1302_write(0x8E, 0x00);
1006   4              DS1302_write(0xD0, time_12);
1007   4              DS1302_write(0x8E, 0x80);
1008   4              
1009   4              if(power_flag == DS1302_VCC_OFF)
1010   4                DS1302_power_off();
1011   4              
1012   4              refresh_screen_now = 1;
1013   4              btn_state = 0;
1014   4              return;
1015   4            }
1016   3          }
1017   2        }
1018   1      
1019   1        
1020   1        else if (mode==MODE_CLASS  | mode==MODE_CALENDAR)// | mode==MODE_COUNT_DOWN
1021   1        {
1022   2          max_[0] = 12;
1023   2          max_[1] = 31; 
1024   2          max_[2] = 7; 
1025   2          if(edit)
1026   2          {
1027   3            if (btn_state == 1) //btn1 ¶Ì
1028   3            {
1029   4              hot_num = (hot_num+1)%3;
1030   4              refresh_screen_now = 1;
1031   4              btn_state = 0;
1032   4              return;
1033   4            }
1034   3            if (btn_state == 3) //btn2 ¶Ì
1035   3            {
1036   4              now_time[hot_num+2] = now_time[hot_num+2] % max_[hot_num] + 1;
1037   4              DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // month
1038   4              DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
1039   4              DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
1040   4              refresh_screen_now = 1;
1041   4              btn_state = 0;
1042   4              return;
1043   4            }
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 18  

1044   3            if(btn_state == 4)// btn2 ³¤
1045   3            {
1046   4              add_count--;
1047   4              if(add_count==0)
1048   4              {
1049   5                add_count = ADD_DT;
1050   5                now_time[hot_num+2] = now_time[hot_num+2] % max_[hot_num] + 1;
1051   5                DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // mon
             -th
1052   5                DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
1053   5                DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
1054   5                refresh_screen_now = 1;
1055   5                last_blink = 0;
1056   5                return;
1057   5              }
1058   4            }
1059   3          }
1060   2        }
1061   1        
1062   1        if (btn_state==2 && BTN1_INT_FLAG == 0)
1063   1        {
1064   2          btn_state = 0;
1065   2          return;
1066   2        }
1067   1        if (btn_state==4 && BTN2_INT_FLAG == 0)
1068   1        {
1069   2          btn_state = 0;
1070   2          return;
1071   2        }
1072   1        if (btn_state==3)
1073   1        {
1074   2          btn_state = 0;
1075   2          return;
1076   2        }
1077   1      }
1078          
1079          void wake_up_init()
1080          {
1081   1        shutdown_mode_flag = 0;
1082   1        
1083   1        P1_OUT_EN;
1084   1        P3_OUT_EN;
1085   1        P54_OUT_EN;
1086   1        P32_IN_EN;
1087   1        P33_IN_EN;
1088   1        
1089   1        DS1302_CLK = 0;  
1090   1        
1091   1        SCREEN_RST = 1;
1092   1        SCREEN_CS = 0;
1093   1        SCREEN_BG = 0;
1094   1        SCREEN_init();
1095   1        
1096   1        mode = MODE_TIME;
1097   1        read_now_time();
1098   1        refresh_screen_now = 1;
1099   1      
1100   1        shutdown_mode_flag = 0;
1101   1      }
1102          
1103          
1104          void INT0_Isr() interrupt 0 
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 19  

1105          {
1106   1        if(BTN_1 == 1) // ÉÏÉýÑØ
1107   1        {
1108   2          BTN1_INT_FLAG = 1;
1109   2        }
1110   1        else // ÏÂ½µÑØ
1111   1        {
1112   2          if(shutdown_mode_flag)
1113   2            shutdown();
1114   2          else
1115   2          {
1116   3            if (btn1_press_time>0) //btn2 ¶Ì°´
1117   3              btn_state = 1;
1118   3            
1119   3            if(btn_state==2)
1120   3              btn_state = 0;
1121   3            
1122   3            lift = 1;
1123   3            BTN1_INT_FLAG = 0;
1124   3            btn1_press_time = 0;
1125   3          }
1126   2        }
1127   1      
1128   1      }
1129          
1130          void INT1_Isr() interrupt 2 
1131          {
1132   1        if(BTN_2 == 1) // ÉÏÉýÑØ
1133   1        {
1134   2          BTN2_INT_FLAG = 1;
1135   2          
1136   2        }
1137   1        else // ÏÂ½µÑØ
1138   1        {
1139   2          if(shutdown_mode_flag)
1140   2            shutdown();
1141   2          else
1142   2          {
1143   3            if (btn2_press_time>0) //btn2 ¶Ì°´
1144   3              btn_state = 3;
1145   3            
1146   3            if(btn_state==4)
1147   3              btn_state = 0;
1148   3            
1149   3            lift = 1;
1150   3            BTN2_INT_FLAG = 0;
1151   3            btn2_press_time = 0;
1152   3          }
1153   2        }
1154   1      }
1155          
1156          void main()
1157          {
1158   1        low_speed();
1159   1      
1160   1        P1_OUT_EN;
1161   1        P3_OUT_EN;
1162   1        P54_OUT_EN;
1163   1        P32_IN_EN;
1164   1        P33_IN_EN;
1165   1        
1166   1        DS1302_RST = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 20  

1167   1        DS1302_CLK = 0;
1168   1        DS1302_DAT = 0;
1169   1      
1170   1      
1171   1        SCREEN_init();
1172   1        
1173   1        DS1302_init();
1174   1      
1175   1        
1176   1        // ÖÐ¶Ï
1177   1        EX0 = 1;
1178   1        IT0 = 0; // ÉÏÉýÏÂ½µÑØ¶¼²úÉúÖÐ¶Ï
1179   1        EX1 = 1;
1180   1        IT1 = 0; // ÉÏÉýÏÂ½µÑØ¶¼²úÉúÖÐ¶Ï 
1181   1        
1182   1        EA = 1; // ×ÜÖÐ¶Ï
1183   1      
1184   1      
1185   1        BUZZER = 0;
1186   1        
1187   1        P_SW2 |= 0x80;
1188   1        ADCTIM = 0x3f; // ²ÉÑùÊ±¼ä
1189   1        P_SW2 &= 0x7f;
1190   1        ADCCFG = 0x0f; // ×ó¶ÔÆë
1191   1        ADC_CONTR = 0x0F; // ¶ÔÄÚ²¿1.19V½øÐÐ²ÉÑù ADCµçÔ´¹Ø±Õ
1192   1      
1193   1          
1194   1        while(1)
1195   1        {
1196   2          refresh_count--;
1197   2          if(refresh_count == 0) 
1198   2          {
1199   3            refresh_screen_now = 1;
1200   3           
1201   3            if(edit&&(mode!=MODE_SETTING))
1202   3            {
1203   4              refresh_count = 0x10;
1204   4            }
1205   3            else
1206   3            {
1207   4              refresh_count = 2150; // 58s
1208   4              
1209   4              read_now_time();
1210   4              if(now_time[NOW_TIME_HOUR]>=23 || now_time[NOW_TIME_HOUR]<6 )
1211   4                shutdown();
1212   4              else if (shutdown_mode_flag)
1213   4                wake_up_init();
1214   4            }
1215   3          }
1216   2          
1217   2          if(refresh_screen_now)
1218   2          {
1219   3            refresh_screen_now = 0;
1220   3            refresh_screen();
1221   3          }  
1222   2          btn();
1223   2        
1224   2          if(btn_state)
1225   2          {
1226   3            btn_process();    
1227   3          }
1228   2      
C51 COMPILER V9.60.0.0   MAIN                                                              12/24/2022 11:07:38 PAGE 21  

1229   2          //delay_5ms();
1230   2          WKTCL=0x30;
1231   2          WKTCH=0x80;
1232   2          
1233   2          PCON = 0x02;
1234   2          _nop_();
1235   2          _nop_();
1236   2        }
1237   1      }
1238          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4406    ----
   CONSTANT SIZE    =   3018    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
