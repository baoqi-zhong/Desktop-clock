C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\install\keil_install\C51\BIN\C51.EXE Src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          ÍêÈ«¹Ø±Õ 20uA
   3          DS1302 2mA
   4          
   5          delay¸Ä³Éslp5ms ¾²Ì¬0.4mA
   6          */
   7          
   8          
   9          #include "STC8.h"
  10          #include "stc_common.h"
  11          #include "main.h"
  12          #include <intrins.h>
  13          
  14          
  15          unsigned char mode = MODE_TIME;
  16          unsigned char settings_focus = 0;
  17          
  18          unsigned char shutdown_mode_flag = 0; // 0ÎÞ 1¹Ø±ÕËùÓÐ 2Í£Ö¹¾§ÕñÊ¡µç
  19          
  20          unsigned char now_time[5] = {12, 00, 10, 23, 7};
  21          unsigned char display_num_data[4];
  22          
  23          unsigned char BTN1_INT_FLAG=0, BTN2_INT_FLAG=0;
  24          unsigned char btn1_press_time=0, btn2_press_time=0; // ¼ÇÂ¼¸÷¸ö°´Å¥³¤°´µÄÀÛ¼ÆÊ±¼ä
  25          unsigned char btn_state = 0, add_state;
  26          
  27          unsigned char time_12 = 0;
  28          unsigned char edit = 0; // ÊÇ·ñ´¦ÓÚ±à¼­ÖÐ
  29          unsigned char lift = 0;
  30          
  31          unsigned char max_[3]; // ¸÷¸öÎ»µÄ×î´óÊýÖµ£¬¶¯Ì¬ÉèÖÃ
  32          unsigned char hot_num = 0; // ÕýÔÚÐÞ¸ÄµÄÊÇÇ°Á½Î»»¹ÊÇºóÁ½Î»£¬0/1
  33          unsigned char last_blink = 0;
  34          
  35          unsigned char refresh_screen_now = 1;
  36          unsigned int refresh_count = 0x01;
  37          unsigned char add_count = ADD_DT;
  38          
  39          sfr IRCBAND = 0x9D; // Æµ¶Î
  40          sfr LIRTRIM = 0x9E; // ÆµÂÊÎ¢µ÷¼Ä´æÆ÷
  41          sfr IRTRIM = 0x9F; // ÆµÂÊµ÷Õû¼Ä´æÆ÷
  42          
  43          
  44          void high_speed()
  45          {
  46   1        TR0 = 0; // ¹Ø±Õ¶¨Ê±Æ÷
  47   1        P_SW2 = 0x80;
  48   1        
  49   1        IRC24MCR |= 0x80; // ´ò¿ªHRC
  50   1        while(!(IRC24MCR & 1));
  51   1        CKSEL = 0; // ÄÚ²¿32K  
  52   1        CLKDIV = 15; // »Ö¸´Ä¬ÈÏ  
  53   1        IRC32KCR &= 0x7F; // ¹Ø±ÕLRC
  54   1        P_SW2 = 0x00; 
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 2   

  55   1      }
  56          
  57          void low_speed()
  58          {
  59   1        P_SW2 = 0x80;
  60   1        IRC32KCR |= 0x80; // ´ò¿ªLRC
  61   1        while(!(IRC32KCR & 1));
  62   1        CKSEL = 3; // ÄÚ²¿32K
  63   1        CLKDIV = 0;
  64   1        IRC24MCR &= 0x7F; // ¹Ø±ÕHRC
  65   1      
  66   1        P_SW2 = 0x00; 
  67   1        TR0 = 1; // ´ò¿ª¶¨Ê±Æ÷
  68   1      }
  69          
  70          void delay(unsigned int time)
  71          {
  72   1        unsigned int time_;
  73   1        P_SW2 = 0x80;
  74   1        if(CLKDIV==15)
  75   1        {
  76   2          P_SW2 = 0x00;
  77   2          for(time_=0;time_<time;time_++)
  78   2          {
  79   3            unsigned char i, j; // 2MHz
  80   3            i = 2;
  81   3            j = 239;
  82   3            do
  83   3            {
  84   4              while (--j);
  85   4            } while (--i);
  86   3          }
  87   2        }
  88   1        else
  89   1        {
  90   2          P_SW2 = 0x00;
  91   2          for(time_=0;time_<time;time_++)
  92   2          {
  93   3            unsigned char i; // 32KHz
  94   3            i = 8;
  95   3            while (--i);
  96   3          }
  97   2        }
  98   1      }
  99          
 100          
 101          void shutdown()
 102          {
 103   1        // ±ê×¼Ë«Ïò
 104   1        P0M0 = 0x03;
 105   1        P0M1 = 0x03;
 106   1        P1M0 = 0x00;
 107   1        P1M1 = 0x00;
 108   1        P2M0 = 0x00;
 109   1        P2M1 = 0x00;
 110   1        P3M0 = 0x00;
 111   1        P3M1 = 0x0F;
 112   1      
 113   1        P4M0 = 0x00;
 114   1        P4M1 = 0x00;
 115   1        P5M0 = 0x00;
 116   1        P5M1 = 0x00;
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 3   

 117   1      
 118   1        P0 = 0;
 119   1        P1 = 0;
 120   1        P2 = 0;
 121   1        P3 = 0;
 122   1        P4 = 0;
 123   1        P5 = 0;
 124   1      
 125   1        DS1302_VCC = DS1302_VCC_OFF;
 126   1        
 127   1        WKTCL=0xFE;  //µôµç»½ÐÑ¶¨Ê±Æ÷¹Ø±Õ£¡
 128   1        WKTCH=0xFF;
 129   1        
 130   1        shutdown_mode_flag = 1;
 131   1        PCON = 0x02;
 132   1        _nop_();
 133   1        _nop_();
 134   1        _nop_();
 135   1        _nop_(); 
 136   1        
 137   1        //shutdown_mode_flag = 0;
 138   1        refresh_count = 1;
 139   1        refresh_screen_now = 0;
 140   1      }
 141          
 142          
 143          // DS1302
 144          void DS1302_shift_out(unsigned char data_)
 145          {
 146   1        unsigned char i;
 147   1        P36_OUT_EN; // DS1302_DAT
 148   1        for (i = 0; i < 8; i++)
 149   1        {
 150   2          // 1302ÏÈ´«ÈëµÄÊÇµÍÎ»µÄ
 151   2          DS1302_DAT = data_ >> i & 1;
 152   2          //ÉÏÉýÑØÐ´Êý¾Ý
 153   2          DS1302_CLK = 1;
 154   2          DS1302_CLK = 0;
 155   2        }
 156   1      }
 157          
 158          unsigned char DS1302_shift_in()
 159          {
 160   1        unsigned char i, data_=0;
 161   1        P36_IN_EN; // DS1302_DAT
 162   1        for (i = 0; i < 8; i++)
 163   1        {
 164   2          //ÏÂ½µÑØ¶ÁÊý¾Ý ÔÚDS1302_shift_outº¯ÊýÀ­µÍÖ®ºóÂíÉÏ¶Á
 165   2          if (DS1302_DAT==1)
 166   2            data_ |= 1 << i;
 167   2          
 168   2          DS1302_CLK = 1;
 169   2          DS1302_CLK = 0;
 170   2        }
 171   1        return data_;
 172   1      }
 173          
 174          void DS1302_write(unsigned char address, unsigned char data_)
 175          {
 176   1        DS1302_DAT = 0;
 177   1      
 178   1        DS1302_RST = 1;
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 4   

 179   1        DS1302_shift_out(address);
 180   1        DS1302_shift_out(data_);
 181   1        DS1302_RST = 0;
 182   1        
 183   1      }
 184          
 185          unsigned char DS1302_read(unsigned char address)
 186          {
 187   1        unsigned char data_;
 188   1      
 189   1        DS1302_DAT = 0;
 190   1      
 191   1        DS1302_RST = 1;
 192   1        DS1302_shift_out(address);
 193   1        data_ = DS1302_shift_in();
 194   1        DS1302_RST = 0;
 195   1        return data_;
 196   1      }
 197          
 198          void DS1302_power_on()
 199          {
 200   1        DS1302_VCC = DS1302_VCC_ON;
 201   1        delay(5);
 202   1      }
 203          
 204          void DS1302_power_off()
 205          {
 206   1        delay(5);
 207   1        DS1302_VCC = DS1302_VCC_OFF;
 208   1      }
 209          
 210          void DS1302_init()
 211          {
 212   1        DS1302_power_on();
 213   1        DS1302_write(0x8E, 0x00); // Ð´±£»¤off
 214   1        
 215   1        //DS1302_write(0x90, 0xA5); // ³äµç
 216   1        set_now_time();
 217   1        DS1302_write(0x8C, 0x22); // year
 218   1        DS1302_write(0x80, DS1302_read(0x81) & 0x7F); // ¾§ÕñÆðÕð // bug:Ã¿´ÎÉèÖÃÃëÖ®ºó£¬ºÁÃë»áÇåÁã¡£ËùÒÔÔÚ1sÄÚ²
             -»¶ÏresetµÄ»°£¬Ê±¼ä»á¿¨×¡²»¶¯
 219   1      
 220   1        DS1302_write(0x8E, 0x80); // Ð´±£»¤on
 221   1        DS1302_power_off();
 222   1      }
 223          
 224          void read_now_time()
 225          {
 226   1        unsigned char time_data, power_flag;
 227   1        
 228   1        power_flag = DS1302_VCC;
 229   1        if(power_flag == DS1302_VCC_OFF)
 230   1          DS1302_power_on();
 231   1      
 232   1        time_data = DS1302_read(0x85); // hour
 233   1        now_time[NOW_TIME_HOUR] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 234   1      
 235   1        time_data = DS1302_read(0x83); // min
 236   1        now_time[NOW_TIME_MINUTE] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 237   1      
 238   1        time_data = DS1302_read(0x89); // month
 239   1        now_time[NOW_TIME_MONTH] = (time_data >> 4 & 7) * 10 + (time_data & 15);
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 5   

 240   1        
 241   1        time_data = DS1302_read(0x87); // day
 242   1        now_time[NOW_TIME_DAY] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 243   1        
 244   1        
 245   1        now_time[NOW_TIME_WEEKDAY] = DS1302_read(0x8B); // week
 246   1        
 247   1        if(power_flag == DS1302_VCC_OFF)
 248   1          DS1302_power_off();
 249   1      }
 250          
 251          void set_now_time()
 252          {
 253   1        unsigned char power_flag;
 254   1        power_flag = DS1302_VCC;
 255   1        if(power_flag == DS1302_VCC_OFF)
 256   1          DS1302_power_on();
 257   1        
 258   1        DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 259   1        DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // min
 260   1        DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // month
 261   1        DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
 262   1        DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
 263   1        
 264   1        if(power_flag == DS1302_VCC_OFF)
 265   1          DS1302_power_off();
 266   1      }
 267          
 268          
 269          // screen
 270          void SCREEN_shift(unsigned char data_)
 271          {
 272   1        SPDAT = data_;
 273   1        while (!(SPSTAT & 0x80));
 274   1        SPSTAT = 0xc0;   
 275   1      }
 276          
 277          void SCREEN_write_cmd(unsigned char cmd)
 278          {
 279   1        SCREEN_DC = 0;
 280   1        SCREEN_shift(cmd);
 281   1      }
 282          
 283          void SCREEN_write_data(unsigned char data_)
 284          {
 285   1        SCREEN_DC = 1;
 286   1        SCREEN_shift(data_);
 287   1      }
 288          
 289          void SCREEN_clear()
 290          {
 291   1        unsigned char x,y;
 292   1        high_speed();
 293   1        for (y = 0; y < 8; y++)
 294   1        {
 295   2          SCREEN_write_cmd(0xB0 + y);//ÐÐ
 296   2          SCREEN_write_cmd(0x00);//ÆðÊ¼x
 297   2          SCREEN_write_cmd(0x10);//ÆðÊ¼x
 298   2          SCREEN_DC = 1;
 299   2          for (x = 0; x < 128; x++)
 300   2          {
 301   3            SCREEN_shift(0x00);
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 6   

 302   3          }
 303   2        }
 304   1        low_speed();
 305   1      }
 306          
 307          void SCREEN_init()
 308          {
 309   1        const unsigned char code init_cmds[] = {
 310   1          0xE2, // Èí¼þ¸´Î»
 311   1          
 312   1          0x2F, // ¿ªÉýÑ¹Æ÷ ¿ªµçÑ¹µ÷ÕûÆ÷ ¿ªµçÑ¹¸úËæÆ÷
 313   1          
 314   1          0x24, // ´Öµ÷¶Ô±È¶È
 315   1          0x81, 31, // Ï¸µ÷¶Ô±È¶È
 316   1      
 317   1          0x40, // ÉèÖÃpage1
 318   1          0xC8, // ÉÏÏÂµßµ¹
 319   1          0xAF,// ´ò¿ªÏÔÊ¾
 320   1        };
 321   1        unsigned char i;
 322   1        
 323   1        SCREEN_RST = 0;
 324   1        delay(1);
 325   1        SCREEN_RST = 1;
 326   1        
 327   1        SCREEN_CS = 0;
 328   1        SCREEN_BG = 0;
 329   1        
 330   1        // SPI init
 331   1        SPCTL = 0xD0;                               //Ê¹ÄÜSPIÖ÷»úÄ£Ê½ ºöÂÔSSÖ÷´Ó»úÑ¡ÔñÒý½Å
 332   1        SPSTAT = 0xc0;                              //ÇåÖÐ¶Ï±êÖ¾
 333   1        
 334   1        SCREEN_DC = 0; // cmd
 335   1        for (i = 0; i < 8; i++)
 336   1        {
 337   2          SCREEN_write_cmd(init_cmds[i]);
 338   2          delay(1);
 339   2        }
 340   1        SCREEN_clear();
 341   1      }
 342          
 343          void print_line(unsigned char start_x, unsigned char start_y, char words[])
 344          {
 345   1        unsigned char x, character;
 346   1        SCREEN_write_cmd(0xB0 + start_y); //ÐÐ
 347   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 348   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 349   1      
 350   1        character = 0; // ´«ÈëµÄwords½áÎ²ÊÇ\0 (ºóÃæÓÃcharacterµÄÊ±ºòÒª-1)
 351   1        while (words[character++])
 352   1        {
 353   2          SCREEN_DC = 1; // data
 354   2          for (x = 0; x < 5; x++)
 355   2            SCREEN_shift(FONT[(words[character - 1] - START_CHAR) * 5 + x]);
 356   2          SCREEN_shift(0x00);
 357   2        }
 358   1      }
 359          
 360          void print_var(unsigned char start_x, unsigned char start_y, unsigned char num, unsigned char len)
 361          {
 362   1        unsigned char x;
 363   1        SCREEN_write_cmd(0xB0 + start_y); //ÐÐ
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 7   

 364   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 365   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 366   1        
 367   1        SCREEN_DC = 1; // data
 368   1        if(len==3)
 369   1        {
 370   2          for (x = 0; x < 5; x++)
 371   2            SCREEN_shift(FONT[('0' + num/100 - START_CHAR) * 5 + x]);
 372   2          SCREEN_shift(0x00);
 373   2        }
 374   1        if(len>=2)
 375   1        {
 376   2          for (x = 0; x < 5; x++)
 377   2            SCREEN_shift(FONT[('0' + num/10%10 - START_CHAR) * 5 + x]);
 378   2          SCREEN_shift(0x00);
 379   2        }
 380   1        if(len>=1)
 381   1        {
 382   2          for (x = 0; x < 5; x++)
 383   2            SCREEN_shift(FONT[('0' + num%10 - START_CHAR) * 5 + x]);
 384   2          SCREEN_shift(0x00);
 385   2        }
 386   1      }
 387          
 388          
 389          void print_big_num(unsigned char start_x, unsigned char start_y,unsigned char num)
 390          {
 391   1        unsigned char x, y;
 392   1        for (y = 0; y < 5; y++)
 393   1        {
 394   2          SCREEN_write_cmd(0xB0 + start_y + y); //ÐÐ
 395   2          SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 396   2          SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 397   2          
 398   2          SCREEN_DC = 1; // data
 399   2          if(num==10)
 400   2            for (x = 0; x < 24; x++)
 401   2              SCREEN_shift(0x00);
 402   2          else
 403   2            for (x = 0; x < 24; x++)
 404   2              SCREEN_shift(BIG_NUM_FONT[num*120 + y*24+x]);
 405   2         }
 406   1      }
 407          
 408          void print_small_num(unsigned char start_x, unsigned char start_y,unsigned char num)
 409          {
 410   1        unsigned char x, y;
 411   1        for (y = 0; y < 4; y++)
 412   1        {
 413   2          SCREEN_write_cmd(0xB0 + start_y + y); //ÐÐ
 414   2          SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 415   2          SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 416   2          
 417   2          SCREEN_DC = 1; // data
 418   2          if(num==10)
 419   2            for (x = 0; x < 16; x++)
 420   2              SCREEN_shift(0x00);
 421   2          else
 422   2            for (x = 0; x < 16; x++)
 423   2              SCREEN_shift(SMALL_NUM_FONT[num*48 + y*16+x]);
 424   2         }
 425   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 8   

 426          
 427          void print_time(unsigned char start_x, unsigned char start_y,unsigned char nums[])
 428          {
 429   1        unsigned char x,digit;
 430   1       
 431   1        last_blink = 1 - last_blink;
 432   1        if (edit == 1 && last_blink==0 && btn_state!=4)
 433   1        {
 434   2          if (hot_num == 0)
 435   2          {
 436   3            display_num_data[0] = 10;
 437   3            display_num_data[1] = 10;
 438   3          }
 439   2          else
 440   2          {
 441   3            display_num_data[2] = 10;
 442   3            display_num_data[3] = 10;
 443   3          }
 444   2        }
 445   1        
 446   1        if(display_num_data[0] == 0)
 447   1          display_num_data[0] = 10;
 448   1        
 449   1        for(digit=0;digit<4;digit++)
 450   1        {
 451   2          print_big_num(start_x+NUM_START_OFFSET[digit], start_y,nums[digit]);
 452   2        }
 453   1        
 454   1        start_x += NUM_START_OFFSET[4];
 455   1        SCREEN_write_cmd(0xB1 + start_y); //ÐÐ
 456   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 457   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 458   1        
 459   1        SCREEN_DC = 1; // data
 460   1        for (x = 0; x < 4; x++)
 461   1          SCREEN_shift(0x7E);
 462   1        
 463   1        SCREEN_write_cmd(0xB3 + start_y); //ÐÐ
 464   1        SCREEN_write_cmd(0x00 + (start_x & 0xF)); //ÆðÊ¼x µÍ4Î»
 465   1        SCREEN_write_cmd(0x10 + (start_x >> 4)); //ÆðÊ¼x ¸ß4Î»
 466   1        
 467   1        SCREEN_DC = 1; // data
 468   1        for (x = 0; x < 4; x++)
 469   1          SCREEN_shift(0x7E);
 470   1      }
 471          
 472          void update_display_num_data()
 473          {
 474   1        // Õý³£ÏÔÊ¾Ö÷Ê±¼ä
 475   1      
 476   1        if(time_12 && now_time[NOW_TIME_HOUR]>12)
 477   1        {
 478   2          display_num_data[0] = (now_time[NOW_TIME_HOUR] - 12) / 10;
 479   2          display_num_data[1] = (now_time[NOW_TIME_HOUR] - 12) % 10;
 480   2        }
 481   1        else
 482   1        {
 483   2          display_num_data[0] = now_time[NOW_TIME_HOUR] / 10;
 484   2          display_num_data[1] = now_time[NOW_TIME_HOUR] % 10;
 485   2        }
 486   1      
 487   1        display_num_data[2] = now_time[NOW_TIME_MINUTE] / 10;
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 9   

 488   1        display_num_data[3] = now_time[NOW_TIME_MINUTE] % 10;
 489   1      }
 490          
 491          
 492          void draw_class(unsigned char day)
 493          {
 494   1        // day ´ÓÁã¿ªÊ¼
 495   1        unsigned char line, x, lesson;
 496   1        unsigned int temp;
 497   1      
 498   1        for (line = 0; line < 2; line++)
 499   1        {
 500   2          SCREEN_write_cmd(0xB2 +line); //ÐÐ
 501   2          SCREEN_write_cmd(0x00); //ÆðÊ¼x µÍ4Î»
 502   2          SCREEN_write_cmd(0x10); //ÆðÊ¼x ¸ß4Î»
 503   2          
 504   2          SCREEN_DC = 1; // data
 505   2          for(lesson = 0; lesson<9; lesson++)
 506   2          {
 507   3            temp = lesson_table[lesson+day*9]*28+line*14; 
 508   3            if(lesson==5)
 509   3            {
 510   4              SCREEN_shift(0x00);
 511   4              SCREEN_shift(0x00);
 512   4              SCREEN_shift(0x00);
 513   4            }
 514   3            for (x = 0; x <14; x++)
 515   3            {
 516   4              SCREEN_shift(CHINESE_FONT[temp+x]);
 517   4            }
 518   3          }
 519   2        }
 520   1      }
 521          
 522          void print_small_time(unsigned char start_x, unsigned char start_y, unsigned char now_time_hour, unsigned 
             -char now_time_min)
 523          {
 524   1        if(time_12 && now_time_hour>12)
 525   1          now_time_hour = now_time_hour%12;
 526   1      
 527   1         
 528   1        if(now_time_hour>=10)
 529   1          print_var(start_x, start_y, now_time_hour,2);
 530   1        else
 531   1        {
 532   2          print_line(start_x, start_y, " ");
 533   2          print_var(start_x+5, start_y, now_time_hour,1);
 534   2        }
 535   1        
 536   1        print_line(start_x+12, start_y, ":");
 537   1        print_var(start_x+17, start_y, now_time_min,2);
 538   1      
 539   1      }
 540          
 541          void print_next_time(unsigned char start_x, unsigned char start_y)
 542          {
 543   1        unsigned char i;
 544   1        unsigned int now_time_hour, now_time_min;
 545   1        now_time_min = now_time[NOW_TIME_HOUR]*60+now_time[NOW_TIME_MINUTE];
 546   1        for(i=0;i<23;i++)
 547   1        {
 548   2          if(now_time_min<time_table[i])
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 10  

 549   2            break;
 550   2        }
 551   1        now_time_hour = time_table[i]/60;
 552   1        
 553   1        print_small_time(start_x, start_y, now_time_hour, time_table[i]%60);
 554   1      }
 555          
 556          void draw_chinese(unsigned char start_x, unsigned char start_y, unsigned char chinese)
 557          {
 558   1        unsigned char line,x;
 559   1        
 560   1        for (line = 0; line < 2; line++)
 561   1        {
 562   2          SCREEN_write_cmd(0xB0 + start_y + line); //ÐÐ
 563   2          SCREEN_write_cmd(start_x & 0x0F); //ÆðÊ¼x µÍ4Î»
 564   2          SCREEN_write_cmd(0x10 + (start_x>>4)); //ÆðÊ¼x ¸ß4Î»
 565   2          
 566   2          SCREEN_DC = 1; // data
 567   2          for (x = 0; x <14; x++)
 568   2          {
 569   3            SCREEN_shift(CHINESE_FONT[chinese*28+line*14+x]);
 570   3          }
 571   2        }
 572   1      }
 573          void print_day_and_date()
 574          {
 575   1        last_blink = 1-last_blink;
 576   1        
 577   1        if(edit && last_blink==0)
 578   1        {
 579   2          if(hot_num==0)
 580   2            print_line(2,0,"  ");
 581   2          if(hot_num==1)
 582   2            print_line(18,0,"  ");
 583   2          if(hot_num==2)
 584   2            print_line(35,0, "          ");
 585   2        }
 586   1        else
 587   1        {
 588   2          print_line(13, 0, ".");
 589   2          print_var(2,0,now_time[NOW_TIME_MONTH], 2);
 590   2          print_var(18,0,now_time[NOW_TIME_DAY], 2);
 591   2          print_line(35,0, WEEK_NAME[now_time[NOW_TIME_WEEKDAY]-1]);
 592   2        }
 593   1      }
 594          
 595          void draw_count_down()
 596          {
 597   1        unsigned char x;
 598   1        signed int remained_day;
 599   1        
 600   1        remained_day = MONTH_TO_COUNTDOWN[now_time[NOW_TIME_MONTH] - 1] - now_time[NOW_TIME_DAY];
 601   1        if(remained_day<0)
 602   1          remained_day = 0;
 603   1          
 604   1        if(remained_day>99)
 605   1          print_small_num(60,5,remained_day/100);
 606   1        else
 607   1          print_small_num(60,5,10);
 608   1        
 609   1        if(remained_day>9)
 610   1          print_small_num(78,5,(remained_day/10)%10);
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 11  

 611   1        else
 612   1          print_small_num(78,5,10);
 613   1        
 614   1        print_small_num(96,5,remained_day%10);
 615   1        
 616   1        for (x = 0; x < 4; x++)
 617   1          draw_chinese(14*x,6,14+x);
 618   1      
 619   1        draw_chinese(114,6,18);
 620   1      }
 621          
 622          void draw_count_down_big()
 623          {
 624   1        signed int remained_day;
 625   1        
 626   1        remained_day = MONTH_TO_COUNTDOWN[now_time[NOW_TIME_MONTH] - 1] - now_time[NOW_TIME_DAY];
 627   1        if(remained_day<0)
 628   1          remained_day = 0;
 629   1        
 630   1        if(remained_day>99)
 631   1          print_big_num(22,2,remained_day/100);
 632   1        else
 633   1          print_big_num(22,2,10);
 634   1        
 635   1        if(remained_day>9)
 636   1          print_big_num(54,2,(remained_day/10)%10);
 637   1        else
 638   1          print_big_num(54,2,10);
 639   1        
 640   1        print_big_num(86,2,remained_day%10);
 641   1        
 642   1        draw_chinese(2,2,14);
 643   1        draw_chinese(2,5,15);
 644   1        draw_chinese(114,5,18);
 645   1      }
 646          
 647          void draw_calendar()
 648          {
 649   1        unsigned char x, y, i, day_count, start_day, month_days;
 650   1        
 651   1        start_day = (35+now_time[NOW_TIME_WEEKDAY]-now_time[NOW_TIME_DAY])%7;
 652   1      
 653   1        month_days = MAX_MONTH_DAYS[now_time[NOW_TIME_MONTH]-1];
 654   1      
 655   1        day_count = 0;
 656   1        for(x=0;x<start_day;x++)
 657   1        {
 658   2          print_line(x*19+4, 2, " ");
 659   2      
 660   2        }
 661   1        for(x=start_day;x<7;x++)
 662   1        {
 663   2          day_count ++;
 664   2          print_var(x*19+4, 2, day_count, 1);
 665   2          
 666   2        }
 667   1        for(y=1;y<6;y++)
 668   1        {
 669   2          for(x=0;x<7;x++)
 670   2          {
 671   3            day_count ++;
 672   3            if(day_count > month_days)
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 12  

 673   3              print_line(x*19+1, y+2, "  ");
 674   3            else
 675   3            {
 676   4              if(day_count<10)
 677   4              {
 678   5                print_line(x*19+1, y+2, "  ");
 679   5                print_var(x*19+4, y+2, day_count, 1);
 680   5              }
 681   4              else
 682   4                print_var(x*19+1, y+2, day_count, 2);
 683   4              
 684   4            }
 685   3      
 686   3          }
 687   2        }
 688   1        
 689   1        // table
 690   1        for(y=0;y<6;y++)
 691   1        {
 692   2          SCREEN_write_cmd(0xB2 + y); //ÐÐ
 693   2          for(x=0;x<6;x++)
 694   2          {
 695   3            SCREEN_write_cmd(0x00 + ((x*19+16) & 0xF)); //ÆðÊ¼x µÍ4Î»
 696   3            SCREEN_write_cmd(0x10 + ((x*19+16) >> 4)); //ÆðÊ¼x ¸ß4Î»
 697   3            SCREEN_write_data(0xFF);
 698   3          }
 699   2        }
 700   1        
 701   1        // ±ê³ö½ñÌì
 702   1        
 703   1        y = (start_day + now_time[NOW_TIME_DAY]-1) / 7;
 704   1        SCREEN_write_cmd(0xB2 + y); //ÐÐ
 705   1        SCREEN_write_cmd(0x00 + ((now_time[NOW_TIME_WEEKDAY]*19-21) & 0xF)); //ÆðÊ¼x µÍ4Î»
 706   1        SCREEN_write_cmd(0x10 + ((now_time[NOW_TIME_WEEKDAY]*19-21) >> 4)); //ÆðÊ¼x ¸ß4Î»
 707   1      
 708   1        SCREEN_write_data(0xFF);
 709   1        SCREEN_write_data(0xFF);
 710   1        
 711   1        SCREEN_write_cmd(0x00 + ((now_time[NOW_TIME_WEEKDAY]*19-5) & 0xF)); //ÆðÊ¼x µÍ4Î»
 712   1        SCREEN_write_cmd(0x10 + ((now_time[NOW_TIME_WEEKDAY]*19-5) >> 4)); //ÆðÊ¼x ¸ß4Î»
 713   1      
 714   1        SCREEN_write_data(0xFF);
 715   1        SCREEN_write_data(0xFF);
 716   1        
 717   1        
 718   1        // ÐÇÆÚ
 719   1        SCREEN_write_cmd(0xB1); //ÐÐ
 720   1        SCREEN_write_cmd(0x00); //ÆðÊ¼x µÍ4Î»
 721   1        SCREEN_write_cmd(0x10); //ÆðÊ¼x ¸ß4Î»
 722   1        
 723   1        SCREEN_DC = 1; // data   
 724   1        for (i = 0; i < 3; i++)
 725   1          SCREEN_shift(0x20); 
 726   1      
 727   1        for(x=0;x<7;x++)
 728   1        { 
 729   2          SCREEN_shift(0x00); 
 730   2          for (i = 0; i < 5; i++)
 731   2            SCREEN_shift(FONT[(WEEK_NAME[x][0] - START_CHAR) * 5 + i]);
 732   2          SCREEN_shift(0x00); 
 733   2          for (i = 0; i < 6; i++)
 734   2            SCREEN_shift(0x20);
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 13  

 735   2          SCREEN_shift(0xE0); 
 736   2          for (i = 0; i < 5; i++)
 737   2            SCREEN_shift(0x20);
 738   2        }
 739   1      
 740   1      
 741   1      }
 742          
 743          
 744          void refresh_screen()
 745          {
 746   1        unsigned char time_data;
 747   1        high_speed();
 748   1        
 749   1        if(mode==MODE_TIME)
 750   1        {
 751   2          time_data = DS1302_read(0x85); // hour
 752   2          now_time[NOW_TIME_HOUR] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 753   2      
 754   2          time_data = DS1302_read(0x83); // min
 755   2          now_time[NOW_TIME_MINUTE] = (time_data >> 4 & 7) * 10 + (time_data & 15);
 756   2      
 757   2          update_display_num_data();
 758   2          
 759   2          if(now_time[NOW_TIME_HOUR]>12)
 760   2            print_line(2,0, "PM");
 761   2          else
 762   2            print_line(2,0, "AM");
 763   2          
 764   2          print_next_time(98, 0);
 765   2      
 766   2          print_time(2,2,display_num_data);
 767   2          SCREEN_BG = 0;
 768   2        }
 769   1        else if (mode == MODE_COUNT_DOWN)
 770   1        {
 771   2          read_now_time();
 772   2          
 773   2          print_day_and_date();
 774   2          
 775   2          print_small_time(98,0,now_time[NOW_TIME_HOUR], now_time[NOW_TIME_MINUTE]);
 776   2          
 777   2          draw_count_down_big();
 778   2        }
 779   1        else if (mode == MODE_CLASS)
 780   1        {
 781   2          read_now_time();
 782   2          print_day_and_date();
 783   2          
 784   2          // 6µãÖÓÖ®ºóÏÔÊ¾µÚ¶þÌìµÄ¿Î±í
 785   2          if(now_time[NOW_TIME_HOUR] > 17)
 786   2          {
 787   3            print_line(99,0, "tomo");
 788   3            draw_class(now_time[NOW_TIME_WEEKDAY] % 7);
 789   3          }
 790   2          else
 791   2          {
 792   3            print_line(99,0, "today");
 793   3            draw_class(now_time[NOW_TIME_WEEKDAY] - 1);
 794   3          }
 795   2          draw_count_down();
 796   2      
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 14  

 797   2          SCREEN_BG = 0;
 798   2        }
 799   1        else if (mode == MODE_CALENDAR)
 800   1        {
 801   2          read_now_time();
 802   2          
 803   2          print_day_and_date();
 804   2          
 805   2          draw_calendar();
 806   2        }
 807   1        else if (mode == MODE_SETTING)
 808   1        {
 809   2          SCREEN_BG = edit;
 810   2      
 811   2          print_line(2,0, "Countdown Clock");
 812   2          print_line(2,1, "Ver. 4.1");
 813   2          
 814   2          
 815   2          print_line(2,6, "- Designed by");
 816   2          print_line(2,7, "- Baoqi-zhong :D");
 817   2      
 818   2          //SCREEN_BG = 0;
 819   2        }
 820   1        
 821   1        low_speed();
 822   1      }
 823          
 824          void btn()
 825          {
 826   1        if (lift == 1) // »¹Ã»³¤°´¹»
 827   1        {
 828   2          if (BTN1_INT_FLAG == 1 && BTN2_INT_FLAG == 0)
 829   2            btn1_press_time += 1;
 830   2          else
 831   2            btn1_press_time = 0;
 832   2          
 833   2          if (BTN2_INT_FLAG == 1 && BTN1_INT_FLAG == 0)
 834   2            btn2_press_time += 1;
 835   2          else
 836   2            btn2_press_time = 0;
 837   2        }
 838   1        
 839   1        if (btn1_press_time > LONG_PRESS_TIME)
 840   1        {
 841   2          // btn1 ³¤°´
 842   2          btn_state = 2;
 843   2          btn1_press_time = 0;
 844   2          lift = 0;
 845   2        }
 846   1        if (btn2_press_time > LONG_PRESS_TIME)
 847   1        {
 848   2          // btn2 ³¤°´
 849   2          btn_state = 4;
 850   2          btn2_press_time = 0;
 851   2          lift = 0;
 852   2        }
 853   1      }
 854          
 855          void btn_process()
 856          {
 857   1        unsigned char power_flag;
 858   1      
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 15  

 859   1        if (btn_state == 1 & edit==0 & settings_focus==0) //btn1 ¶Ì
 860   1        {
 861   2          delay(1);
 862   2          mode = (mode + 1) % MAX_MODE;
 863   2          SCREEN_clear();
 864   2          refresh_screen_now = 1;
 865   2          btn_state = 0;
 866   2         
 867   2          return;
 868   2        }
 869   1        
 870   1        if (btn_state == 2) //btn1 ³¤
 871   1        {
 872   2          if (mode!=MODE_SETTING)
 873   2          {
 874   3            refresh_screen_now = 1;
 875   3            if (edit==1)
 876   3            {
 877   4              edit = 0;
 878   4              //TMR0_DIS;
 879   4              DS1302_write(0x8E, 0x80);
 880   4              DS1302_power_off();
 881   4            }
 882   3            else
 883   3            {
 884   4              edit = 1;
 885   4              hot_num = 0;
 886   4              refresh_count = 0x2F;
 887   4              add_count = ADD_DT;
 888   4              //TMR0_EN;
 889   4              DS1302_power_on();
 890   4              DS1302_write(0x8E, 0x00);
 891   4            }
 892   3            btn_state = 0;
 893   3            return;
 894   3          }
 895   2          else
 896   2          {
 897   3            btn_state = 0;
 898   3            return;
 899   3          }
 900   2          
 901   2          if(mode==MODE_SETTING)
 902   2          {
 903   3            refresh_screen_now = 1;
 904   3      
 905   3            if (settings_focus==0)
 906   3              settings_focus = 1;
 907   3            else
 908   3              settings_focus = 0;
 909   3            
 910   3            btn_state = 0;
 911   3            return; 
 912   3          }
 913   2        }
 914   1      
 915   1        
 916   1        if(mode==MODE_TIME)
 917   1        {
 918   2          max_[0] = 24;
 919   2          max_[1] = 60; 
 920   2          if(edit==1)
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 16  

 921   2          {
 922   3            if (btn_state == 1) //btn1 ¶Ì
 923   3            {
 924   4              hot_num = 1 - hot_num;
 925   4              refresh_screen_now = 1;
 926   4              btn_state = 0;
 927   4              return;
 928   4            }
 929   3            if (btn_state == 3) //btn2 ¶Ì
 930   3            {
 931   4              now_time[hot_num] = (now_time[hot_num] + 1) % max_[hot_num];
 932   4              DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 933   4              DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // min
 934   4              refresh_screen_now = 1;
 935   4              last_blink = 0;
 936   4              btn_state = 0;
 937   4              return;
 938   4            }
 939   3            
 940   3            if(btn_state == 4)// btn2 ³¤
 941   3            {
 942   4              add_count--;
 943   4              if(add_count==0)
 944   4              {
 945   5                add_count = ADD_DT;
 946   5                now_time[hot_num] = (now_time[hot_num] + 1) % max_[hot_num];
 947   5                DS1302_write(0x84, (now_time[NOW_TIME_HOUR] / 10 << 4) + now_time[NOW_TIME_HOUR] % 10); // hour
 948   5                DS1302_write(0x82, (now_time[NOW_TIME_MINUTE] / 10 << 4) + now_time[NOW_TIME_MINUTE] % 10); // m
             -in
 949   5                refresh_screen_now = 1;
 950   5                last_blink = 0;
 951   5                return;
 952   5              }
 953   4            }
 954   3          }
 955   2          else
 956   2          {
 957   3            if (btn_state == 3) //btn2 ¶Ì
 958   3            {
 959   4              
 960   4              time_12 = 1 - time_12;
 961   4              
 962   4              power_flag = DS1302_VCC;
 963   4              if(power_flag == DS1302_VCC_OFF)
 964   4                DS1302_power_on();
 965   4              
 966   4              DS1302_write(0x8E, 0x00);
 967   4              DS1302_write(0xD0, time_12);
 968   4              DS1302_write(0x8E, 0x80);
 969   4              
 970   4              if(power_flag == DS1302_VCC_OFF)
 971   4                DS1302_power_off();
 972   4              
 973   4              refresh_screen_now = 1;
 974   4              btn_state = 0;
 975   4              return;
 976   4            }
 977   3          }
 978   2        }
 979   1      
 980   1        
 981   1        else if (mode==MODE_CLASS | mode==MODE_COUNT_DOWN | mode==MODE_CALENDAR)
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 17  

 982   1        {
 983   2          max_[0] = 12;
 984   2          max_[1] = 31; 
 985   2          max_[2] = 7; 
 986   2          if(edit==1)
 987   2          {
 988   3            if (btn_state == 1) //btn1 ¶Ì
 989   3            {
 990   4              hot_num = (hot_num+1)%3;
 991   4              refresh_screen_now = 1;
 992   4              btn_state = 0;
 993   4              return;
 994   4            }
 995   3            if (btn_state == 3) //btn2 ¶Ì
 996   3            {
 997   4              now_time[hot_num+2] = now_time[hot_num+2] % max_[hot_num] + 1;
 998   4              DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // month
 999   4              DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
1000   4              DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
1001   4              refresh_screen_now = 1;
1002   4              btn_state = 0;
1003   4              return;
1004   4            }
1005   3            if(btn_state == 4)// btn2 ³¤
1006   3            {
1007   4              add_count--;
1008   4              if(add_count==0)
1009   4              {
1010   5                add_count = ADD_DT;
1011   5                now_time[hot_num+2] = now_time[hot_num+2] % max_[hot_num] + 1;
1012   5                DS1302_write(0x88, (now_time[NOW_TIME_MONTH] / 10 << 4) + now_time[NOW_TIME_MONTH] % 10); // mon
             -th
1013   5                DS1302_write(0x86, (now_time[NOW_TIME_DAY] / 10 << 4) + now_time[NOW_TIME_DAY] % 10); // day
1014   5                DS1302_write(0x8A, now_time[NOW_TIME_WEEKDAY]); // week
1015   5                refresh_screen_now = 1;
1016   5                last_blink = 0;
1017   5                return;
1018   5              }
1019   4            }
1020   3          }
1021   2        }
1022   1        
1023   1        if (btn_state==2 && BTN1_INT_FLAG == 0)
1024   1        {
1025   2          btn_state = 0;
1026   2          return;
1027   2        }
1028   1        if (btn_state==4 && BTN2_INT_FLAG == 0)
1029   1        {
1030   2          btn_state = 0;
1031   2          return;
1032   2        }
1033   1        if (btn_state==3)
1034   1        {
1035   2          btn_state = 0;
1036   2          return;
1037   2        }
1038   1      }
1039          
1040          void wake_up_init()
1041          {
1042   1        shutdown_mode_flag = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 18  

1043   1        
1044   1        P1_OUT_EN;
1045   1        P3_OUT_EN;
1046   1        P54_OUT_EN;
1047   1        P32_IN_EN;
1048   1        P33_IN_EN;
1049   1        
1050   1        DS1302_CLK = 0;  
1051   1        
1052   1        SCREEN_RST = 1;
1053   1        SCREEN_CS = 0;
1054   1        SCREEN_BG = 0;
1055   1        SCREEN_init();
1056   1        
1057   1        mode = MODE_TIME;
1058   1        read_now_time();
1059   1        refresh_screen_now = 1;
1060   1      }
1061          
1062          
1063          void INT0_Isr() interrupt 0 
1064          {
1065   1        if(BTN_1 == 1) // ÉÏÉýÑØ
1066   1        {
1067   2          if(shutdown_mode_flag==1)
1068   2            wake_up_init();
1069   2          else
1070   2          {
1071   3            BTN1_INT_FLAG = 1;
1072   3          }
1073   2        }
1074   1        else // ÏÂ½µÑØ
1075   1        {
1076   2          if(shutdown_mode_flag==1)
1077   2            shutdown();
1078   2          else
1079   2          {
1080   3            if (btn1_press_time>0) //btn2 ¶Ì°´
1081   3              btn_state = 1;
1082   3            
1083   3            if(btn_state==2)
1084   3              btn_state = 0;
1085   3            
1086   3            lift = 1;
1087   3            BTN1_INT_FLAG = 0;
1088   3            btn1_press_time = 0;
1089   3          }
1090   2        }
1091   1      
1092   1      }
1093          
1094          void INT1_Isr() interrupt 2 
1095          {
1096   1        if(BTN_2 == 1) // ÉÏÉýÑØ
1097   1        {
1098   2          if(shutdown_mode_flag==1)
1099   2            wake_up_init();
1100   2          else
1101   2          {
1102   3            BTN2_INT_FLAG = 1;
1103   3          }
1104   2        }
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 19  

1105   1        else // ÏÂ½µÑØ
1106   1        {
1107   2          if(shutdown_mode_flag==1)
1108   2            shutdown();
1109   2          else
1110   2          {
1111   3            if (btn2_press_time>0) //btn2 ¶Ì°´
1112   3              btn_state = 3;
1113   3            
1114   3            if(btn_state==4)
1115   3              btn_state = 0;
1116   3            
1117   3            lift = 1;
1118   3            BTN2_INT_FLAG = 0;
1119   3            btn2_press_time = 0;
1120   3          }
1121   2        }
1122   1      }
1123          
1124          void main()
1125          {
1126   1        low_speed();
1127   1      
1128   1        P1_OUT_EN;
1129   1        P3_OUT_EN;
1130   1        P54_OUT_EN;
1131   1        P32_IN_EN;
1132   1        P33_IN_EN;
1133   1        
1134   1        DS1302_RST = 0;
1135   1        DS1302_CLK = 0;
1136   1        DS1302_DAT = 0;
1137   1      
1138   1      
1139   1        SCREEN_init();
1140   1        
1141   1        DS1302_init();
1142   1      
1143   1        
1144   1        // ÖÐ¶Ï
1145   1        EX0 = 1;
1146   1        IT0 = 0; // ÉÏÉýÏÂ½µÑØ¶¼²úÉúÖÐ¶Ï
1147   1        EX1 = 1;
1148   1        IT1 = 0; // ÉÏÉýÏÂ½µÑØ¶¼²úÉúÖÐ¶Ï 
1149   1        
1150   1        EA = 1; // ×ÜÖÐ¶Ï
1151   1      
1152   1      
1153   1        BUZZER = 0;
1154   1      
1155   1        while(1)
1156   1        {
1157   2          refresh_count--;
1158   2          if(refresh_count == 0) 
1159   2          {
1160   3            refresh_screen_now = 1;
1161   3           
1162   3            if(edit&&(mode!=MODE_SETTING))
1163   3            {
1164   4              refresh_count = 0x40;
1165   4            }
1166   3            else
C51 COMPILER V9.60.0.0   MAIN                                                              10/23/2022 08:11:48 PAGE 20  

1167   3            {
1168   4              refresh_count = 0x19BC; // 57s
1169   4              
1170   4              read_now_time();
1171   4              if(now_time[NOW_TIME_HOUR]>=23 || now_time[NOW_TIME_HOUR]<6 )
1172   4              {
1173   5                //TMR2_CLR;
1174   5                //TMR2_EN;
1175   5                shutdown();
1176   5              }
1177   4            }
1178   3          }
1179   2          
1180   2          if(refresh_screen_now)
1181   2          {
1182   3            refresh_screen_now = 0;
1183   3            if(shutdown_mode_flag)
1184   3              SCREEN_init();
1185   3            refresh_screen();
1186   3          }  
1187   2          btn();
1188   2        
1189   2          if(btn_state)
1190   2          {
1191   3            btn_process();    
1192   3          }
1193   2      
1194   2          //delay(5);
1195   2          WKTCL=0x0A;  //µôµç»½ÐÑ¶¨Ê±Æ÷¹Ø±Õ£¡
1196   2          WKTCH=0x80;
1197   2          
1198   2          PCON = 0x02;
1199   2          _nop_();
1200   2          _nop_();
1201   2        }
1202   1      }
1203          
*** WARNING C294 IN LINE 901 OF Src\main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4572    ----
   CONSTANT SIZE    =   2990    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
